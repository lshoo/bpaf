<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Applicative functors? What is it about?"><meta name="keywords" content="rust, rustlang, rust-lang, _applicative"><title>bpaf::_applicative - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-93196c7a1c3542a8.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../bpaf/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../bpaf/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module _applicative</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">bpaf</a>::<wbr><a class="mod" href="#">_applicative</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/bpaf/_applicative.rs.html#1-239">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="applicative-functors-what-is-it-about"><a href="#applicative-functors-what-is-it-about">Applicative functors? What is it about?</a></h2>
<p>You don’t need to read/understand this chapter in order to use the library but it might
help to understand what makes it tick.</p>
<h3 id="category-theory"><a href="#category-theory">Category theory</a></h3>
<p>Category theory, also called Abstract Nonsense, is a general theory about mathematical
structures and their relations. <em>Category</em> in CT constists of two sorts of abstractions:
<em>objects</em> and <em>morphisms</em> along with some extra rules:</p>
<ul>
<li>objects don’t expose any information other than the name and only serve as start and end points for morphisms</li>
<li>morphisms must compose with associative composition</li>
<li>there must be an <em>identity morphism</em> for every object that maps the object to itself</li>
</ul>
<p>A simple example of a category would be a category where objects are Rust types (here: <code>u8</code> ..
<code>u64</code>) and morphisms are functions between those types (here: <code>a</code>, <code>b</code> and <code>c</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>a(i: u8) -&gt; u16 {
    <span class="number">3000 </span>+ i <span class="kw">as </span>u16
}

<span class="kw">fn </span>b(i: u16) -&gt; u32 {
    <span class="number">40000 </span>+ i <span class="kw">as </span>u32
}

<span class="kw">fn </span>c(i: u32) -&gt; u64 {
    <span class="number">40000 </span>+ i <span class="kw">as </span>u64
}

<span class="doccomment">/// Identity morphism
</span><span class="kw">fn </span>id&lt;T&gt;(i: T) -&gt; T {
    i
}

<span class="doccomment">/// morphism composition:
/// `comp (a, comp(b, c))` gives the same results as `comp(comp(a, b), c)`
</span><span class="kw">fn </span>comp&lt;F, G, A, B, C&gt;(f: F, g: G) -&gt; <span class="kw">impl </span>Fn(A) -&gt; C
<span class="kw">where
    </span>F: Fn(A) -&gt; B,
    G: Fn(B) -&gt; C,
{
    <span class="kw">move </span>|i| g(f(i))
}</code></pre></div>
<h3 id="composition-and-decomposition"><a href="#composition-and-decomposition">Composition and decomposition</a></h3>
<p>Decomposition is one of the keys to solving big problems - you break down big problem into a
bunch of small problems, solve them separately and compose back a solution. Decomposition is
not required by computers but makes it easier to think about a problem: magical number for
human short term memory is 7 plus minus 2 objects. Category theory, studies relations and
composition can be a valuable tool: after all decomposition only makes sense when you can
combine components back into a solution. Imperative algorithms that operate in terms of
mutating variables are harder decompose - individual pieces need to be aware of the variables,
functional and declarative approaches make it easier: calculating a sum of all the numbers in a
vector can be decomposed into running an iterator over it and applying <code>fold</code> to it: <code>fold</code>
doesn’t need to know about iteration shape, iterator doesn’t need to know about how values are
used.</p>
<p>In category theory you are not allowed to look inside the objects at all and can distinguish
between them only by means of the composition so as long as implemented API obeys the
restrictions set by category theory - it should be very composable.</p>
<h3 id="functors"><a href="#functors">Functors</a></h3>
<p>Let’s start by talking about what a <code>Functor</code> is. Wikipedia defines it as a “design pattern
that allows for a generic type to apply a function inside without changing the structure of
the generic type”. Sounds scary, but in Rust terms it’s a trait that takes a value or values
in a container (or more general <em>value in a context</em> ) such as <code>Option&lt;A&gt;</code> and a function
<code>fn(A) -&gt; B</code> and gives you <code>Option&lt;B&gt;</code> back.</p>
<p>Closest analogy in a real code you can write in Rust right now would be modifying an <code>Option</code>
using only <code>Option::map</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>plus_one(input: <span class="prelude-ty">Option</span>&lt;u32&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    input.map(|i| i + <span class="number">1</span>)
}

<span class="kw">let </span>present = <span class="prelude-val">Some</span>(<span class="number">10</span>);
<span class="kw">let </span>absent = <span class="prelude-val">None</span>;

<span class="macro">assert_eq!</span>(plus_one(present), <span class="prelude-val">Some</span>(<span class="number">11</span>));
<span class="macro">assert_eq!</span>(plus_one(absent), <span class="prelude-val">None</span>);</code></pre></div>
<p><code>Vec</code>, <code>Result</code> and other types that implement <code>map</code> are <code>Functors</code> as well, but <code>Functor</code>
is not limited just to containers - you don’t have to have a value inside to be able to
manipulate it. In fact a regular rust function is also a <code>Functor</code> if you squint hard enough.
Consider <code>Reader</code> that allows you to perform transformations on a <em>value in a context</em> <code>T</code>
without having any value until it the execution time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Reader&lt;T&gt;(Box&lt;<span class="kw">dyn </span>Fn(T) -&gt; T&gt;);
<span class="kw">impl</span>&lt;T: <span class="lifetime">&#39;static</span>&gt; Reader&lt;T&gt; {
    <span class="doccomment">/// Initialize an new value in a context
    </span><span class="kw">fn </span>new() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>(Box::new(|x| x))
    }

    <span class="doccomment">/// Modify a value in a context
    </span><span class="kw">fn </span>map&lt;F:  Fn(T) -&gt; T + <span class="lifetime">&#39;static</span>&gt;(<span class="self">self</span>, f: F) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>(Box::new(<span class="kw">move </span>|x| f((<span class="self">self</span>.<span class="number">0</span>)(x))))
    }

    <span class="doccomment">/// Apply the changes by giving it the initial value
    </span><span class="kw">fn </span>run(<span class="self">self</span>, input: T) -&gt; T {
        (<span class="self">self</span>.<span class="number">0</span>)(input)
    }
}

<span class="kw">let </span>val = Reader::&lt;u32&gt;::new();
<span class="kw">let </span>val = val.map(|x| x + <span class="number">1</span>);
<span class="kw">let </span>res = val.run(<span class="number">10</span>);
<span class="macro">assert_eq!</span>(res, <span class="number">11</span>);</code></pre></div>
<p>Not all the collections are <code>Functors</code> - by <code>Functor</code> laws mapping the <em>value in context</em>
shouldn’t change the shape so any collections where shape depends on a value, such as <code>HashSet</code>
or <code>BTreeSet</code> are out.</p>
<h3 id="applicative-functors"><a href="#applicative-functors">Applicative Functors</a></h3>
<p><code>map</code> in <code>Functor</code> is limited to a single <em>value in a context</em>, <code>Applicative Functor</code> extends it
to operations combining multiple values, closest Rust analogy would be doing computations on
<code>Option</code> or <code>Result</code> using only <code>?</code>, having <code>Some</code>/<code>Ok</code> around the whole expression and not using <code>return</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>add_numbers(input_a: <span class="prelude-ty">Option</span>&lt;u32&gt;, input_b: <span class="prelude-ty">Option</span>&lt;u32&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    <span class="prelude-val">Some</span>(input_a<span class="question-mark">? </span>+ input_b<span class="question-mark">?</span>)
}

<span class="kw">let </span>present_1 = <span class="prelude-val">Some</span>(<span class="number">10</span>);
<span class="kw">let </span>present_2 = <span class="prelude-val">Some</span>(<span class="number">20</span>);
<span class="kw">let </span>absent = <span class="prelude-val">None</span>;

<span class="macro">assert_eq!</span>(add_numbers(present_1, present_2), <span class="prelude-val">Some</span>(<span class="number">30</span>));
<span class="macro">assert_eq!</span>(add_numbers(present_1, absent), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(add_numbers(absent, absent), <span class="prelude-val">None</span>);</code></pre></div>
<p>Similarly to <code>Functors</code>, <code>Applicative Functors</code> are not limited to containers and can
represent <em>a value in an arbitrary context</em>.</p>
<p><code>Try</code> trait (<code>?</code>) for <code>Option</code> and <code>Result</code> short circuits when it finds a missing value,
but <code>Applicative Functors</code> in general don’t have to - in fact to implement dynamic completion
<code>bpaf</code> needs to check items past the first failure point to collect all the possible
completions.</p>
<h3 id="alternative-functors"><a href="#alternative-functors">Alternative Functors</a></h3>
<p>So far <code>Applicative Functors</code> allow us to create structs containing multiple fields out of
individual parsers for each field. <code>Alternative</code> extends <code>Applicative</code> with two extra
things: one for combining two <em>values in a context</em> into one and and an idenity element
for this operation. In Rust a closest analogy would be <code>Option::or</code> and <code>Option::None</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>pick_number(a: <span class="prelude-ty">Option</span>&lt;u32&gt;, b: <span class="prelude-ty">Option</span>&lt;u32&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    a.or(b)
}

<span class="kw">let </span>present_1 = <span class="prelude-val">Some</span>(<span class="number">10</span>);
<span class="kw">let </span>present_2 = <span class="prelude-val">Some</span>(<span class="number">20</span>);
<span class="kw">let </span>empty = <span class="prelude-val">None</span>;
<span class="macro">assert_eq!</span>(pick_number(present_1, present_2), present_1);
<span class="macro">assert_eq!</span>(pick_number(present_1, empty), present_1);
<span class="macro">assert_eq!</span>(pick_number(empty, present_1), present_1);
<span class="macro">assert_eq!</span>(pick_number(empty, empty), empty);</code></pre></div>
<h3 id="parser-trait-and-construct-macro"><a href="#parser-trait-and-construct-macro"><code>Parser</code> trait and <code>construct!</code> macro</a></h3>
<p><a href="../trait.Parser.html" title="Parser"><code>Parser</code></a> trait defines a context for values and gives access to <code>Functor</code> laws and <a href="../macro.construct.html" title="construct!"><code>construct!</code></a>
macro allows to compose several values according to <code>Applicative</code> and <code>Alternative</code> laws.</p>
<h3 id="so-why-use-applicative-functors-then"><a href="#so-why-use-applicative-functors-then">So why use <code>Applicative Functors</code> then?</a></h3>
<p>As a user I want to be able to express requirements using full power of Rust algebraic
datatypes: <code>struct</code> for product types and <code>enum</code> for sum types. To give an example -
<code>cargo-show-asm</code> asks user to specify what to output - Intel or AT&amp;T asm, LLVM or Rust’s MIR
and opts to represent it as one of four flags: <code>--intel</code>, <code>--att</code>, <code>--llvm</code> and <code>--mir</code>. While
each flag can be though of a boolean value - present/absent - consuming it as an <code>enum</code> with four
possible values is much more convenient compared to a struct-like thing that can have any
combination of the flags inside:</p>
<div class="example-wrap"><pre class="language-no_check"><code>/// Format selection as enum - program needs to deal with just one format
enum Format {
    Intel,
    Att,
    Llvm,
    Mir
}

/// Format selection as struct - can represent any possible combination of formats
struct Formats {
    intel: bool,
    att: bool,
    llvm: bool,
    mir: bool,
}
</code></pre></div>
<p><code>Applicative</code> interface gives just enough power to compose simple parsers as an arbitrary tree
ready for consumption.</p>
<p>As a library author I need to be able to extract information from the tree constructed by user
to generate <code>--help</code> information and do command line completion. As long as the tree uses only
<code>Applicative</code> powers - it is possible to evaluate it without giving it any input.
Adding <code>Monadic</code> powers (deciding what to parse next depending on the previous input) would
make this impossible.</p>
<p>So <code>Applicative Functors</code> sits right in the middle between what users want to express and
library can consume.</p>
<p>To recap - all sorts of Functors listed here only define laws to how individual parts are
composed, how values in context can be transformed and how pure values can be turned into a
functor, but not how the values are parsed or how they can be extracted.</p>
<h3 id="putting-the-values-into-a-context"><a href="#putting-the-values-into-a-context">Putting the values into a context</a></h3>
<p>Similarly to how <code>Reader</code> defined above <code>bpaf</code>’s <code>Parsers</code> don’t actually have values inside
until they are executed. Instead starting points (<a href="../params/struct.NamedArg.html#method.flag"><code>flag</code></a>, <a href="../fn.positional.html" title="positional"><code>positional</code></a>,
<a href="../params/struct.NamedArg.html#method.argument"><code>argument</code></a>, etc) define what exactly needs to be consumed, various mapping
functions define transformations, <a href="../macro.construct.html" title="construct!"><code>construct!</code></a> composes them and defines the relative order
values should be consumed. Not everything present inside <a href="../trait.Parser.html" title="Parser"><code>Parser</code></a> can be repesented in terms
of plain applicative functors - specifically <a href="../trait.Parser.html#method.parse"><code>parse</code></a> is not and it is best
though of as a function that takes one applicative and gives a different applicative back.
The actual values will show up inside once <code>bpaf</code> starts running the <a href="../struct.OptionParser.html" title="OptionParser"><code>OptionParser</code></a> with
<a href="../struct.OptionParser.html#method.run"><code>run</code></a>.</p>
<h3 id="taking-the-results-out"><a href="#taking-the-results-out">Taking the results out</a></h3>
<p>The rest of the execution is relatively simple: getting console arguments from OS, doing the
initial split into short/long flags and standalone words, disambiguating groups of short
options from short options with attached values and applying all the transformations like
<code>Reader::run</code> above would do.</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bpaf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0 (2c8cc3432 2023-03-06)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-08ddfdda51b8ee2e.css" ></div></body></html>